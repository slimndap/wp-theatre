// Generated by CoffeeScript 1.7.1

/*
--------------------------------------------
     Begin list.js
--------------------------------------------
 */

(function() {
  ;(function(){

/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve path.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize path relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at path with callback definition.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the parent path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at path.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-classes/index.js", function(exports, require, module){
/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap el in a ClassList.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for el.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el) throw new Error('A DOM element reference is required');
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class name if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class name when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching re.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class name, can force state via force.
 *
 * For browsers that support classList, but do not support force yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var str = this.el.className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class name is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

});
require.register("segmentio-extend/index.js", function(exports, require, module){

module.exports = function extend (object) {
    // Takes an unlimited number of extenders.
    var args = Array.prototype.slice.call(arguments, 1);

    // For each extender, copy their properties on our object.
    for (var i = 0, source; source = args[i]; i++) {
        if (!source) continue;
        for (var property in source) {
            object[property] = source[property];
        }
    }

    return object;
};
});
require.register("component-indexof/index.js", function(exports, require, module){
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
});
require.register("component-event/index.js", function(exports, require, module){
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind el event type to fn.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind el event type's callback fn.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};
});
require.register("timoxley-to-array/index.js", function(exports, require, module){
/**
 * Convert an array-like object into an Array.
 * If collection is already an Array, then will return a clone of collection.
 *
 * @param {Array | Mixed} collection An Array or array-like object to convert e.g. arguments or NodeList
 * @return {Array} Naive conversion of collection to a new Array.
 * @api public
 */

module.exports = function toArray(collection) {
  if (typeof collection === 'undefined') return []
  if (collection === null) return [null]
  if (collection === window) return [window]
  if (typeof collection === 'string') return [collection]
  if (isArray(collection)) return collection
  if (typeof collection.length != 'number') return [collection]
  if (typeof collection === 'function' && collection instanceof Function) return [collection]

  var arr = []
  for (var i = 0; i < collection.length; i++) {
    if (Object.prototype.hasOwnProperty.call(collection, i) || i in collection) {
      arr.push(collection[i])
    }
  }
  if (!arr.length) return []
  return arr
}

function isArray(arr) {
  return Object.prototype.toString.call(arr) === "[object Array]";
}

});
require.register("javve-events/index.js", function(exports, require, module){
var events = require('event'),
  toArray = require('to-array');

/**
 * Bind el event type to fn.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el = toArray(el);
  for ( var i = 0; i < el.length; i++ ) {
    events.bind(el[i], type, fn, capture);
  }
};

/**
 * Unbind el event type's callback fn.
 *
 * @param {Element} el, NodeList, HTMLCollection or Array
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el = toArray(el);
  for ( var i = 0; i < el.length; i++ ) {
    events.unbind(el[i], type, fn, capture);
  }
};

});
require.register("javve-get-by-class/index.js", function(exports, require, module){
/**
 * Find all elements with class className inside container.
 * Use single = true to increase performance in older browsers
 * when only one element is needed.
 *
 * @param {String} className
 * @param {Element} container
 * @param {Boolean} single
 * @api public
 */

module.exports = (function() {
  if (document.getElementsByClassName) {
    return function(container, className, single) {
      if (single) {
        return container.getElementsByClassName(className)[0];
      } else {
        return container.getElementsByClassName(className);
      }
    };
  } else if (document.querySelector) {
    return function(container, className, single) {
      className = '.' + className;
      if (single) {
        return container.querySelector(className);
      } else {
        return container.querySelectorAll(className);
      }
    };
  } else {
    return function(container, className, single) {
      var classElements = [],
        tag = '*';
      if (container == null) {
        container = document;
      }
      var els = container.getElementsByTagName(tag);
      var elsLen = els.length;
      var pattern = new RegExp("(^|\\s)"+className+"(\\s|$)");
      for (var i = 0, j = 0; i < elsLen; i++) {
        if ( pattern.test(els[i].className) ) {
          if (single) {
            return els[i];
          } else {
            classElements[j] = els[i];
            j++;
          }
        }
      }
      return classElements;
    };
  }
})();

});
require.register("javve-get-attribute/index.js", function(exports, require, module){
/**
 * Return the value for attr at element.
 *
 * @param {Element} el
 * @param {String} attr
 * @api public
 */

module.exports = function(el, attr) {
  var result = (el.getAttribute && el.getAttribute(attr)) || null;
  if( !result ) {
    var attrs = el.attributes;
    var length = attrs.length;
    for(var i = 0; i < length; i++) {
      if (attr[i] !== undefined) {
        if(attr[i].nodeName === attr) {
          result = attr[i].nodeValue;
        }
      }
    }
  }
  return result;
}
});
require.register("javve-natural-sort/index.js", function(exports, require, module){
/*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */

module.exports = function(a, b, options) {
  var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
    sre = /(^[ ]*|[ ]*$)/g,
    dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
    hre = /^0x[0-9a-f]+$/i,
    ore = /^0/,
    options = options || {},
    i = function(s) { return options.insensitive && (''+s).toLowerCase() || ''+s },
    // convert all to strings strip whitespace
    x = i(a).replace(sre, '') || '',
    y = i(b).replace(sre, '') || '',
    // chunk/tokenize
    xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
    yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
    // numeric, hex or date detection
    xD = parseInt(x.match(hre)) || (xN.length != 1 && x.match(dre) && Date.parse(x)),
    yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,
    oFxNcL, oFyNcL,
    mult = options.desc ? -1 : 1;
  // first try and sort Hex codes or Dates
  if (yD)
    if ( xD < yD ) return -1 * mult;
    else if ( xD > yD ) return 1 * mult;
  // natural sorting through split numeric strings and default strings
  for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
    // find floats not starting with '0', string or 0 if not defined (Clint Priest)
    oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
    oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
    // handle numeric vs string comparison - number < string - (Kyle Adams)
    if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
    // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
    else if (typeof oFxNcL !== typeof oFyNcL) {
      oFxNcL += '';
      oFyNcL += '';
    }
    if (oFxNcL < oFyNcL) return -1 * mult;
    if (oFxNcL > oFyNcL) return 1 * mult;
  }
  return 0;
};

/*
var defaultSort = getSortFunction();

module.exports = function(a, b, options) {
  if (arguments.length == 1) {
    options = a;
    return getSortFunction(options);
  } else {
    return defaultSort(a,b);
  }
}
*/
});
require.register("javve-to-string/index.js", function(exports, require, module){
module.exports = function(s) {
    s = (s === undefined) ? "" : s;
    s = (s === null) ? "" : s;
    s = s.toString();
    return s;
};

});
require.register("component-type/index.js", function(exports, require, module){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of val.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  return typeof val.valueOf();
};

});
require.register("list.js/index.js", function(exports, require, module){
/*
ListJS with beta 1.0.0
By Jonny Str√∂mberg (www.jonnystromberg.com, www.listjs.com)
*/
(function( window, undefined ) {
"use strict";

var document = window.document,
    getByClass = require('get-by-class'),
    extend = require('extend'),
    indexOf = require('indexof');

var List = function(id, options, values) {

    var self = this,
		init,
        Item = require('./src/item')(self),
        addAsync = require('./src/add-async')(self),
        parse = require('./src/parse')(self);

    init = {
        start: function() {
            self.listClass      = "list";
            self.searchClass    = "search";
            self.sortClass      = "sort";
            self.page           = 200;
            self.i              = 1;
            self.items          = [];
            self.visibleItems   = [];
            self.matchingItems  = [];
            self.searched       = false;
            self.filtered       = false;
            self.handlers       = { 'updated': [] };
            self.plugins        = {};
            self.helpers        = {
                getByClass: getByClass,
                extend: extend,
                indexOf: indexOf
            };

            extend(self, options);

            self.listContainer = (typeof(id) === 'string') ? document.getElementById(id) : id;
            if (!self.listContainer) { return; }
            self.list           = getByClass(self.listContainer, self.listClass, true);

            self.templater      = require('./src/templater')(self);
            self.search         = require('./src/search')(self);
            self.filter         = require('./src/filter')(self);
            self.sort           = require('./src/sort')(self);

            this.items();
            self.update();
            this.plugins();
        },
        items: function() {
            parse(self.list);
            if (values !== undefined) {
                self.add(values);
            }
        },
        plugins: function() {
            for (var i = 0; i < self.plugins.length; i++) {
                var plugin = self.plugins[i];
                self[plugin.name] = plugin;
                plugin.init(self);
            }
        }
    };


    /*
    * Add object to list
    */
    this.add = function(values, callback) {
        if (callback) {
            addAsync(values, callback);
            return;
        }
        var added = [],
            notCreate = false;
        if (values[0] === undefined){
            values = [values];
        }
        for (var i = 0, il = values.length; i < il; i++) {
            var item = null;
            if (values[i] instanceof Item) {
                item = values[i];
                item.reload();
            } else {
                notCreate = (self.items.length > self.page) ? true : false;
                item = new Item(values[i], undefined, notCreate);
            }
            self.items.push(item);
            added.push(item);
        }
        self.update();
        return added;
    };

	this.show = function(i, page) {
		this.i = i;
		this.page = page;
		self.update();
        return self;
	};

    /* Removes object from list.
    * Loops through the list and removes objects where
    * property "valuename" === value
    */
    this.remove = function(valueName, value, options) {
        var found = 0;
        for (var i = 0, il = self.items.length; i < il; i++) {
            if (self.items[i].values()[valueName] == value) {
                self.templater.remove(self.items[i], options);
                self.items.splice(i,1);
                il--;
                i--;
                found++;
            }
        }
        self.update();
        return found;
    };

    /* Gets the objects in the list which
    * property "valueName" === value
    */
    this.get = function(valueName, value) {
        var matchedItems = [];
        for (var i = 0, il = self.items.length; i < il; i++) {
            var item = self.items[i];
            if (item.values()[valueName] == value) {
                matchedItems.push(item);
            }
        }
        return matchedItems;
    };

    /*
    * Get size of the list
    */
    this.size = function() {
        return self.items.length;
    };

    /*
    * Removes all items from the list
    */
    this.clear = function() {
        self.templater.clear();
        self.items = [];
        return self;
    };

    this.on = function(event, callback) {
        self.handlers[event].push(callback);
        return self;
    };

    this.off = function(event, callback) {
        var e = self.handlers[event];
        var index = indexOf(e, callback);
        if (index > -1) {
            e.splice(index, 1);
        }
        return self;
    };

    this.trigger = function(event) {
        var i = self.handlers[event].length;
        while(i--) {
            self.handlers[event][i](self);
        }
        return self;
    };

    this.reset = {
        filter: function() {
            var is = self.items,
                il = is.length;
            while (il--) {
                is[il].filtered = false;
            }
            return self;
        },
        search: function() {
            var is = self.items,
                il = is.length;
            while (il--) {
                is[il].found = false;
            }
            return self;
        }
    };

    this.update = function() {
        var is = self.items,
			il = is.length;

        self.visibleItems = [];
        self.matchingItems = [];
        self.templater.clear();
        for (var i = 0; i < il; i++) {
            if (is[i].matching() && ((self.matchingItems.length+1) >= self.i && self.visibleItems.length < self.page)) {
                is[i].show();
                self.visibleItems.push(is[i]);
                self.matchingItems.push(is[i]);
			} else if (is[i].matching()) {
                self.matchingItems.push(is[i]);
                is[i].hide();
			} else {
                is[i].hide();
			}
        }
        self.trigger('updated');
        return self;
    };

    init.start();
};

module.exports = List;

})(window);

});
require.register("list.js/src/search.js", function(exports, require, module){
var events = require('events'),
    getByClass = require('get-by-class'),
    toString = require('to-string');

module.exports = function(list) {
    var item,
        text,
        columns,
        searchString,
        customSearch;

    var prepare = {
        resetList: function() {
            list.i = 1;
            list.templater.clear();
            customSearch = undefined;
        },
        setOptions: function(args) {
            if (args.length == 2 && args[1] instanceof Array) {
                columns = args[1];
            } else if (args.length == 2 && typeof(args[1]) == "function") {
                customSearch = args[1];
            } else if (args.length == 3) {
                columns = args[1];
                customSearch = args[2];
            }
        },
        setColumns: function() {
            columns = (columns === undefined) ? prepare.toArray(list.items[0].values()) : columns;
        },
        setSearchString: function(s) {
            s = toString(s).toLowerCase();
            s = s.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&"); // Escape regular expression characters
            searchString = s;
        },
        toArray: function(values) {
            var tmpColumn = [];
            for (var name in values) {
                tmpColumn.push(name);
            }
            return tmpColumn;
        }
    };
    var search = {
        list: function() {
            for (var k = 0, kl = list.items.length; k < kl; k++) {
                search.item(list.items[k]);
            }
        },
        item: function(item) {
            item.found = false;
            for (var j = 0, jl = columns.length; j < jl; j++) {
                if (search.values(item.values(), columns[j])) {
                    item.found = true;
                    return;
                }
            }
        },
        values: function(values, column) {
            if (values.hasOwnProperty(column)) {
                text = toString(values[column]).toLowerCase();
                if ((searchString !== "") && (text.search(searchString) > -1)) {
                    return true;
                }
            }
            return false;
        },
        reset: function() {
            list.reset.search();
            list.searched = false;
        }
    };

    var searchMethod = function(str) {
        list.trigger('searchStart');

        prepare.resetList();
        prepare.setSearchString(str);
        prepare.setOptions(arguments); // str, cols|searchFunction, searchFunction
        prepare.setColumns();

        if (searchString === "" ) {
            search.reset();
        } else {
            list.searched = true;
            if (customSearch) {
                customSearch(searchString, columns);
            } else {
                search.list();
            }
        }

        list.update();
        list.trigger('searchComplete');
        return list.visibleItems;
    };

    list.handlers.searchStart = list.handlers.searchStart || [];
    list.handlers.searchComplete = list.handlers.searchComplete || [];

    events.bind(getByClass(list.listContainer, list.searchClass), 'keyup', function(e) {
        var target = e.target || e.srcElement, // IE have srcElement
            alreadyCleared = (target.value === "" && !list.searched);
        if (!alreadyCleared) { // If oninput already have resetted the list, do nothing
            searchMethod(target.value);
        }
    });

    // Used to detect click on HTML5 clear button
    events.bind(getByClass(list.listContainer, list.searchClass), 'input', function(e) {
        var target = e.target || e.srcElement;
        if (target.value === "") {
            searchMethod('');
        }
    });

    list.helpers.toString = toString;
    return searchMethod;
};

});
require.register("list.js/src/sort.js", function(exports, require, module){
var naturalSort = require('natural-sort'),
    classes = require('classes'),
    events = require('events'),
    getByClass = require('get-by-class'),
    getAttribute = require('get-attribute');

module.exports = function(list) {
    list.sortFunction = list.sortFunction || function(itemA, itemB, options) {
        options.desc = options.order == "desc" ? true : false; // Natural sort uses this format
        return naturalSort(itemA.values()[options.valueName], itemB.values()[options.valueName], options);
    };

    var buttons = {
        els: undefined,
        clear: function() {
            for (var i = 0, il = buttons.els.length; i < il; i++) {
                classes(buttons.els[i]).remove('asc');
                classes(buttons.els[i]).remove('desc');
            }
        },
        getOrder: function(btn) {
            var predefinedOrder = getAttribute(btn, 'data-order');
            if (predefinedOrder == "asc" || predefinedOrder == "desc") {
                return predefinedOrder;
            } else if (classes(btn).has('desc')) {
                return "asc";
            } else if (classes(btn).has('asc')) {
                return "desc";
            } else {
                return "asc";
            }
        },
        getInSensitive: function(btn, options) {
            var insensitive = getAttribute(btn, 'data-insensitive');
            if (insensitive === "true") {
                options.insensitive = true;
            } else {
                options.insensitive = false;
            }
        },
        setOrder: function(options) {
            for (var i = 0, il = buttons.els.length; i < il; i++) {
                var btn = buttons.els[i];
                if (getAttribute(btn, 'data-sort') !== options.valueName) {
                    continue;
                }
                var predefinedOrder = getAttribute(btn, 'data-order');
                if (predefinedOrder == "asc" || predefinedOrder == "desc") {
                    if (predefinedOrder == options.order) {
                        classes(btn).add(options.order);
                    }
                } else {
                    classes(btn).add(options.order);
                }
            }
        }
    };
    var sort = function() {
        list.trigger('sortStart');
        options = {};

        var target = arguments[0].currentTarget || arguments[0].srcElement || undefined;

        if (target) {
            options.valueName = getAttribute(target, 'data-sort');
            buttons.getInSensitive(target, options);
            options.order = buttons.getOrder(target);
        } else {
            options = arguments[1] || options;
            options.valueName = arguments[0];
            options.order = options.order || "asc";
            options.insensitive = (typeof options.insensitive == "undefined") ? true : options.insensitive;
        }
        buttons.clear();
        buttons.setOrder(options);

        options.sortFunction = options.sortFunction || list.sortFunction;
        list.items.sort(function(a, b) {
            return options.sortFunction(a, b, options);
        });
        list.update();
        list.trigger('sortComplete');
    };

    // Add handlers
    list.handlers.sortStart = list.handlers.sortStart || [];
    list.handlers.sortComplete = list.handlers.sortComplete || [];

    buttons.els = getByClass(list.listContainer, list.sortClass);
    events.bind(buttons.els, 'click', sort);
    list.on('searchStart', buttons.clear);
    list.on('filterStart', buttons.clear);

    // Helpers
    list.helpers.classes = classes;
    list.helpers.naturalSort = naturalSort;
    list.helpers.events = events;
    list.helpers.getAttribute = getAttribute;

    return sort;
};

});
require.register("list.js/src/item.js", function(exports, require, module){
module.exports = function(list) {
    return function(initValues, element, notCreate) {
        var item = this;

        this._values = {};

        this.found = false; // Show if list.searched == true and this.found == true
        this.filtered = false;// Show if list.filtered == true and this.filtered == true

        var init = function(initValues, element, notCreate) {
            if (element === undefined) {
                if (notCreate) {
                    item.values(initValues, notCreate);
                } else {
                    item.values(initValues);
                }
            } else {
                item.elm = element;
                var values = list.templater.get(item, initValues);
                item.values(values);
            }
        };
        this.values = function(newValues, notCreate) {
            if (newValues !== undefined) {
                for(var name in newValues) {
                    item._values[name] = newValues[name];
                }
                if (notCreate !== true) {
                    list.templater.set(item, item.values());
                }
            } else {
                return item._values;
            }
        };
        this.show = function() {
            list.templater.show(item);
        };
        this.hide = function() {
            list.templater.hide(item);
        };
        this.matching = function() {
            return (
                (list.filtered && list.searched && item.found && item.filtered) ||
                (list.filtered && !list.searched && item.filtered) ||
                (!list.filtered && list.searched && item.found) ||
                (!list.filtered && !list.searched)
            );
        };
        this.visible = function() {
            return (item.elm.parentNode == list.list) ? true : false;
        };
        init(initValues, element, notCreate);
    };
};

});
require.register("list.js/src/templater.js", function(exports, require, module){
var getByClass = require('get-by-class');

var Templater = function(list) {
    var itemSource = getItemSource(list.item),
        templater = this;

    function getItemSource(item) {
        if (item === undefined) {
            var nodes = list.list.childNodes,
                items = [];

            for (var i = 0, il = nodes.length; i < il; i++) {
                // Only textnodes have a data attribute
                if (nodes[i].data === undefined) {
                    return nodes[i];
                }
            }
            return null;
        } else if (item.indexOf("<") !== -1) { // Try create html element of list, do not work for tables!!
            var div = document.createElement('div');
            div.innerHTML = item;
            return div.firstChild;
        } else {
            return document.getElementById(list.item);
        }
    }

    /* Get values from element */
    this.get = function(item, valueNames) {
        templater.create(item);
        var values = {};
        for(var i = 0, il = valueNames.length; i < il; i++) {
            var elm = getByClass(item.elm, valueNames[i], true);
            values[valueNames[i]] = elm ? elm.innerHTML : "";
        }
        return values;
    };

    /* Sets values at element */
    this.set = function(item, values) {
        if (!templater.create(item)) {
            for(var v in values) {
                if (values.hasOwnProperty(v)) {
                    // TODO speed up if possible
                    var elm = getByClass(item.elm, v, true);
                    if (elm) {
                        /* src attribute for image tag & text for other tags */
                        if (elm.tagName === "IMG" && values[v] !== "") {
                            elm.src = values[v];
                        } else {
                            elm.innerHTML = values[v];
                        }
                    }
                }
            }
        }
    };

    this.create = function(item) {
        if (item.elm !== undefined) {
            return false;
        }
        /* If item source does not exists, use the first item in list as
        source for new items */
        var newItem = itemSource.cloneNode(true);
        newItem.removeAttribute('id');
        item.elm = newItem;
        templater.set(item, item.values());
        return true;
    };
    this.remove = function(item) {
        list.list.removeChild(item.elm);
    };
    this.show = function(item) {
        templater.create(item);
        list.list.appendChild(item.elm);
    };
    this.hide = function(item) {
        if (item.elm !== undefined && item.elm.parentNode === list.list) {
            list.list.removeChild(item.elm);
        }
    };
    this.clear = function() {
        /* .innerHTML = ''; fucks up IE */
        if (list.list.hasChildNodes()) {
            while (list.list.childNodes.length >= 1)
            {
                list.list.removeChild(list.list.firstChild);
            }
        }
    };
};

module.exports = function(list) {
    return new Templater(list);
};

});
require.register("list.js/src/filter.js", function(exports, require, module){
module.exports = function(list) {

    // Add handlers
    list.handlers.filterStart = list.handlers.filterStart || [];
    list.handlers.filterComplete = list.handlers.filterComplete || [];

    return function(filterFunction) {
        list.trigger('filterStart');
        list.i = 1; // Reset paging
        list.reset.filter();
        if (filterFunction === undefined) {
            list.filtered = false;
        } else {
            list.filtered = true;
            var is = list.items;
            for (var i = 0, il = is.length; i < il; i++) {
                var item = is[i];
                if (filterFunction(item)) {
                    item.filtered = true;
                } else {
                    item.filtered = false;
                }
            }
        }
        list.update();
        list.trigger('filterComplete');
        return list.visibleItems;
    };
};

});
require.register("list.js/src/add-async.js", function(exports, require, module){
module.exports = function(list) {
    return function(values, callback, items) {
        var valuesToAdd = values.splice(0, 100);
        items = items || [];
        items = items.concat(list.add(valuesToAdd));
        if (values.length > 0) {
            setTimeout(function() {
                addAsync(values, callback, items);
            }, 10);
        } else {
            list.update();
            callback(items);
        }
    };
};
});
require.register("list.js/src/parse.js", function(exports, require, module){
module.exports = function(list) {

    var Item = require('./item')(list);

    var getChildren = function(parent) {
        var nodes = parent.childNodes,
            items = [];
        for (var i = 0, il = nodes.length; i < il; i++) {
            // Only textnodes have a data attribute
            if (nodes[i].data === undefined) {
                items.push(nodes[i]);
            }
        }
        return items;
    };

    var parse = function(itemElements, valueNames) {
        for (var i = 0, il = itemElements.length; i < il; i++) {
            list.items.push(new Item(valueNames, itemElements[i]));
        }
    };
    var parseAsync = function(itemElements, valueNames) {
        var itemsToIndex = itemElements.splice(0, 100); // TODO: If < 100 items, what happens in IE etc?
        parse(itemsToIndex, valueNames);
        if (itemElements.length > 0) {
            setTimeout(function() {
                init.items.indexAsync(itemElements, valueNames);
            }, 10);
        } else {
            list.update();
            // TODO: Add indexed callback
        }
    };

    return function() {
        var itemsToIndex = getChildren(list.list),
            valueNames = list.valueNames;

        if (list.indexAsync) {
            parseAsync(itemsToIndex, valueNames);
        } else {
            parse(itemsToIndex, valueNames);
        }
    };
};

});




















require.alias("component-classes/index.js", "list.js/deps/classes/index.js");
require.alias("component-classes/index.js", "classes/index.js");
require.alias("component-indexof/index.js", "component-classes/deps/indexof/index.js");

require.alias("segmentio-extend/index.js", "list.js/deps/extend/index.js");
require.alias("segmentio-extend/index.js", "extend/index.js");

require.alias("component-indexof/index.js", "list.js/deps/indexof/index.js");
require.alias("component-indexof/index.js", "indexof/index.js");

require.alias("javve-events/index.js", "list.js/deps/events/index.js");
require.alias("javve-events/index.js", "events/index.js");
require.alias("component-event/index.js", "javve-events/deps/event/index.js");

require.alias("timoxley-to-array/index.js", "javve-events/deps/to-array/index.js");

require.alias("javve-get-by-class/index.js", "list.js/deps/get-by-class/index.js");
require.alias("javve-get-by-class/index.js", "get-by-class/index.js");

require.alias("javve-get-attribute/index.js", "list.js/deps/get-attribute/index.js");
require.alias("javve-get-attribute/index.js", "get-attribute/index.js");

require.alias("javve-natural-sort/index.js", "list.js/deps/natural-sort/index.js");
require.alias("javve-natural-sort/index.js", "natural-sort/index.js");

require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
require.alias("javve-to-string/index.js", "list.js/deps/to-string/index.js");
require.alias("javve-to-string/index.js", "to-string/index.js");
require.alias("javve-to-string/index.js", "javve-to-string/index.js");
require.alias("component-type/index.js", "list.js/deps/type/index.js");
require.alias("component-type/index.js", "type/index.js");
if (typeof exports == "object") {
  module.exports = require("list.js");
} else if (typeof define == "function" && define.amd) {
  define(function(){ return require("list.js"); });
} else {
  this["List"] = require("list.js");
}})();

  /*
  --------------------------------------------
       Begin editor.coffee
  --------------------------------------------
   */
  var WPT_Editor_Date, WPT_Editor_Datetime_Control, WPT_Editor_Status_Control, WPT_Editor_Thumbnail_Control, wpt_admin_ticketspage, wpt_editor, wpt_events, wpt_production_create_form, wpt_productions;

  wpt_editor = (function() {
    function wpt_editor(item) {
      this.item = item;
      this.productions = new wpt_productions(this);
      this.events = new wpt_events(this);
      this.production_create_form = new wpt_production_create_form(this);
      this.categories();
      this.seasons();
    }


    /*
    	Set status to busy (show spinner).
     */

    wpt_editor.prototype.busy = function() {
      return this.item.addClass('busy');
    };


    /*
    	Set status to done (hide spinner).
     */

    wpt_editor.prototype.done = function() {
      return this.item.removeClass('busy');
    };


    /*
    	Reset the editor to the default state.
    	
    	Close all production forms.
    	Reset the production create form.
     */

    wpt_editor.prototype.reset = function() {
      this.productions.close();
      return this.production_create_form.reset();
    };

    wpt_editor.prototype.categories = function() {
      this.category_filters = this.item.find('.wpt_editor_filters .categories li a');
      return this.category_filters.click((function(_this) {
        return function(e) {
          var filter;
          filter = jQuery(e.currentTarget);
          if (filter.hasClass('active')) {
            filter.removeClass('active');
            _this.productions.category();
          } else {
            filter.addClass('active');
            _this.productions.category(filter.text());
          }
          return false;
        };
      })(this));
    };

    wpt_editor.prototype.seasons = function() {
      this.season_filters = this.item.find('.wpt_editor_filters .seasons li a');
      return this.season_filters.click((function(_this) {
        return function(e) {
          var filter;
          filter = jQuery(e.currentTarget);
          if (filter.hasClass('active')) {
            filter.removeClass('active');
            _this.productions.season();
          } else {
            filter.addClass('active');
            _this.productions.season(filter.text());
          }
          return false;
        };
      })(this));
    };


    /*
    	Calculate the date offset between WP and the browser.
    	Returns the number of seconds that have to be added to dates that are submitted to the server.
     */

    wpt_editor.prototype.dateoffset = function() {
      var date;
      date = new Date();
      return date.getTimezoneOffset() * 60 * -1 + wpt_editor_ajax.gmt_offset * 60 * 60;
    };

    return wpt_editor;

  })();


  /*
  Form to create a new production.
   */

  wpt_production_create_form = (function() {
    function wpt_production_create_form(editor) {
      this.editor = editor;
      this.form = this.editor.item.find('#wpt_editor_production_form_create');
      this.title = this.form.find('[name=title]');

      /*
      		Open the form as soon as the title gets the focus.
      		Close the production edit form in the productions list.
       */
      this.title.focus((function(_this) {
        return function() {
          _this.open();
          return _this.editor.productions.close();
        };
      })(this));

      /*
      		Save the new production.
      		Block the regular submission of the form.
       */
      this.form.find('form').submit((function(_this) {
        return function() {
          _this.save();
          return false;
        };
      })(this));

      /*
      		Close the form when the reset button is clicked.
       */
      this.reset_button = this.form.find(':reset');
      this.reset_button.click((function(_this) {
        return function() {
          return _this.close();
        };
      })(this));
      this.init();
    }


    /*
    	Initialize the form.
    	Set the title placeholder based on the contents of the productions list.
    	Close the form, ready to receive input.
     */

    wpt_production_create_form.prototype.init = function() {
      if (this.editor.productions.list.items.length > 0) {
        this.title.attr('placeholder', wpt_editor_ajax.start_typing);
      } else {
        this.title.attr('placeholder', wpt_editor_ajax.start_typing_first);
      }

      /*
      		Add a datetime control.
       */
      this.datetime = new WPT_Editor_Datetime_Control(this.form);

      /*
      		Add a tickets status control.
       */
      this.tickets_status = new WPT_Editor_Status_Control(this.form);

      /*
      		Add a thumbnail control
       */
      this.thumbnail = new WPT_Editor_Thumbnail_Control(this.form);
      return this.close();
    };


    /*
    	Open the form.
     */

    wpt_production_create_form.prototype.open = function() {
      return this.form.removeClass('closed');
    };


    /*
    	Close the form.
    	Remove the focus from the title input so it can trigger @open() 
    	as soon as it gets the focus again.
     */

    wpt_production_create_form.prototype.close = function() {
      this.form.addClass('closed');
      return this.title.blur();
    };


    /*
    	Reset the form to the default state.
    	Use the reset button to clear all inputs and close the form.
     */

    wpt_production_create_form.prototype.reset = function() {
      return this.reset_button.click();
    };


    /*
    	Create the new production.
    	Submit the production and event data to the server.
    	Add the new production to the list object.
     */

    wpt_production_create_form.prototype.save = function() {

      /*
      		Collect the event data
       */
      var data, enddate, event_data, event_date, _ref;
      _ref = this.datetime.value(), event_date = _ref[0], enddate = _ref[1];
      event_data = {
        'event_date': event_date + this.editor.dateoffset(),
        'enddate': enddate + this.editor.dateoffset(),
        'venue': this.form.find('input[name=venue]').val(),
        'city': this.form.find('input[name=city]').val(),
        'prices': this.form.find('[name=prices]').val(),
        'tickets_url': this.form.find('input[name=tickets_url]').val(),
        'tickets_button': this.form.find('input[name=tickets_button]').val(),
        'tickets_status': this.tickets_status.value()
      };

      /*
      		Create the production data
       */
      data = {
        'wpt_nonce': wpt_editor_ajax.wpt_nonce,
        'action': 'save',
        'title': this.form.find('input[name=title]').val(),
        'thumbnail': this.thumbnail.value(),
        'excerpt': this.form.find('textarea[name=excerpt]').val(),
        'categories': this.form.find('select[name=categories\\[\\]]').val(),
        'season': this.form.find('select[name=season]').val(),
        'events': [event_data]
      };
      this.editor.busy();

      /*
      		Submit the data to the server.
       */
      return jQuery.post(wpt_editor_ajax.url, data, (function(_this) {
        return function(response) {
          if (response != null) {

            /*
            				When succesful, add the new production to the productions list.
             */
            _this.editor.productions.list.add(response);

            /*
            				Re-activate all productions.
             */
            _this.editor.productions.activate();
          }

          /*
          			Re-initialize the productions list.
          			The list needs to be activated if this is the first production that was added.
           */
          _this.editor.productions.init();

          /*
          			Clear the form and close it.
           */
          _this.reset();
          return _this.editor.done();
        };
      })(this));
    };

    return wpt_production_create_form;

  })();

  wpt_productions = (function() {
    function wpt_productions(editor) {
      var options;
      this.editor = editor;
      options = {
        listClass: 'list',
        item: 'wpt_editor_production_template',
        searchClass: 'wpt_editor_search'
      };
      this.list = new List('wpt_editor_productions', options);
      this.load();
      this.form = this.editor.item.find('#wpt_editor_production_form_template');
      this.init();
    }

    wpt_productions.prototype.init = function() {
      if (this.list.items.length > 0) {
        return this.editor.item.find('.wpt_editor_list').addClass('activated');
      } else {
        return this.editor.item.find('.wpt_editor_list').removeClass('activated');
      }
    };

    wpt_productions.prototype.load = function() {
      var data;
      data = {
        'action': 'productions',
        'wpt_nonce': wpt_editor_ajax.wpt_nonce
      };
      this.editor.busy();
      return jQuery.post(wpt_editor_ajax.url, data, (function(_this) {
        return function(response) {
          if (response != null) {
            _this.list.add(response);
            _this.activate();
          }
          _this.editor.done();
          _this.editor.production_create_form.reset();
          return _this.init();
        };
      })(this));
    };

    wpt_productions.prototype.activate = function() {
      this.editor.item.find('.production > .actions a').unbind('click').click((function(_this) {
        return function(e) {
          var action, production;
          action = jQuery(e.currentTarget).parent();
          production = action.parents('.production');
          if (action.hasClass('edit_link')) {
            _this.edit(production);
          }
          if (action.hasClass('delete_link')) {
            _this["delete"](production);
          }
          if (action.hasClass('view_link')) {
            _this.view(production);
          }
          return false;
        };
      })(this));
      this.form.find('> a.close').unbind('click').click((function(_this) {
        return function(e) {
          _this.close();
          _this.save();
          return false;
        };
      })(this));
      return this.form.find('form').submit(function(e) {
        return false;
      });
    };

    wpt_productions.prototype.close = function() {
      var id, item, values;
      id = this.form.find('input[name=ID]').val();
      if (id !== '') {
        values = {
          title: this.form.find('input[name=title]').val(),
          excerpt: this.form.find('textarea[name=excerpt]').val(),
          categories: this.form.find('select[name=categories\\[\\]]').val(),
          season: this.form.find('select[name=season]').val()
        };
        item = this.list.get('ID', id)[0];
        item.values(values);
      }
      return this.form.parents('.production').removeClass('edit');
    };

    wpt_productions.prototype.edit = function(production) {
      var id, values;
      this.editor.reset();
      this.editor.item.find('.production.edit').removeClass('edit');
      production.addClass('edit');
      id = production.find('>.hidden .ID').text();
      values = this.list.get('ID', id)[0].values();
      production.find('.form').append(this.form);
      this.form.find('input[name=ID]').val(id);
      this.form.find('input[name=title]').val(values.title);
      this.form.find('textarea[name=excerpt]').val(values.excerpt);
      this.form.find('select[name=categories]').val(values.categories);
      this.form.find('select[name=season]').val(values.season);

      /*
      		Add a thumbnail control
       */
      this.thumbnail = new WPT_Editor_Thumbnail_Control(this.form);

      /*
      			Load events
       */
      return this.editor.events.load(id);
    };

    wpt_productions.prototype["delete"] = function(production) {
      var confirm_message, data, id, values;
      id = production.find('>.hidden .ID').text();
      values = this.list.get('ID', id)[0].values();
      confirm_message = wpt_editor_ajax.confirm_message.replace(/%s/g, values.title);
      if (confirm(confirm_message)) {
        data = {
          'wpt_nonce': wpt_editor_ajax.wpt_nonce,
          'action': 'delete',
          'ID': id
        };
        this.editor.busy();
        return jQuery.post(wpt_editor_ajax.url, data, (function(_this) {
          return function(response) {
            _this.list.remove('ID', response);
            _this.editor.done();
            _this.editor.reset();
            return _this.init();
          };
        })(this));
      }
    };

    wpt_productions.prototype.view = function(production) {
      return window.open(production.find('.view_link a').attr('href'));
    };

    wpt_productions.prototype.save = function() {
      var data, id, item;
      id = this.form.find('input[name=ID]').val();
      data = this.list.get('ID', id)[0].values();
      data['wpt_nonce'] = wpt_editor_ajax.wpt_nonce;
      data['action'] = 'save';
      data['events'] = (function() {
        var _i, _len, _ref, _results;
        _ref = this.editor.events.list.items;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          _results.push(item.values());
        }
        return _results;
      }).call(this);
      this.editor.busy();
      return jQuery.post(wpt_editor_ajax.url, data, (function(_this) {
        return function(response) {
          _this.list.get('ID', id)[0].values(response);
          _this.activate();
          _this.init();
          _this.editor.done();

          /*
          				Load events
           */
          return _this.editor.events.load(id);
        };
      })(this));
    };

    wpt_productions.prototype.category = function(category) {
      if (category == null) {
        category = '';
      }
      return this.list.filter(function(item) {
        var categories, search;
        if (category === '') {
          return true;
        } else {
          categories = item.values().categories_html;
          search = '>' + category + '</li>';
          return (categories != null) && categories.indexOf(search) > -1;
        }
      });
    };

    wpt_productions.prototype.season = function(season) {
      if (season == null) {
        season = '';
      }
      return this.list.filter(function(item) {
        if (season === '') {
          return true;
        } else {
          return item.values().season_html === season;
        }
      });
    };

    return wpt_productions;

  })();

  wpt_events = (function() {
    function wpt_events(editor) {
      var options;
      this.editor = editor;
      options = {
        listClass: 'list',
        item: 'wpt_editor_event_template'
      };
      this.list = new List('wpt_editor_events', options);
      this.form = this.editor.productions.form.find('.wpt_editor_event_form');
      this.events = this.editor.productions.form.find('#wpt_editor_events');
    }

    wpt_events.prototype.load = function(production) {
      var data;
      data = {
        'action': 'events',
        'production': production,
        'wpt_nonce': wpt_editor_ajax.wpt_nonce
      };
      this.editor.busy();
      return jQuery.post(wpt_editor_ajax.url, data, (function(_this) {
        return function(response) {
          if (response != null) {
            _this.list.clear();
            _this.list.add(response);
            _this.activate();
          }
          return _this.editor.done();
        };
      })(this));
    };

    wpt_events.prototype.activate = function() {
      this.events.find('.actions a').unbind('click').click((function(_this) {
        return function(e) {
          var action, event;
          action = jQuery(e.currentTarget).parent();
          event = action.parents('.event');
          if (action.hasClass('edit_link')) {
            _this.edit(event);
          }
          if (action.hasClass('delete_link')) {
            _this["delete"](event);
          }
          return false;
        };
      })(this));
      this.form.find('a.close').unbind('click').click((function(_this) {
        return function(e) {
          _this.close();
          return false;
        };
      })(this));
      this.events.find('.add a').unbind('click').click((function(_this) {
        return function(e) {
          var action;
          action = jQuery(e.currentTarget);
          if (action.hasClass('add_link')) {
            _this.add();
          }
          if (action.hasClass('save_link')) {
            _this.close();
          }
          if (action.hasClass('cancel_link')) {
            _this.reset();
          }
          return false;
        };
      })(this));
      this.tickets_status = new WPT_Editor_Status_Control(this.form);
      return this.datetime = new WPT_Editor_Datetime_Control(this.form);
    };

    wpt_events.prototype.add = function() {

      /*
      		Create a new event
       */
      var event_date, values;
      event_date = new WPT_Editor_Date();
      values = {
        event_date: event_date.datetime + this.editor.dateoffset(),
        enddate: event_date.datetime + wpt_editor_ajax.default_duration * 1 + this.editor.dateoffset()
      };
      values[wpt_editor_ajax.order_key] = values.event_date;
      this.list.add(values);
      this.list.update();
      return this.editor.productions.save();

      /*
      		Edit the new event
       */
    };

    wpt_events.prototype.edit = function(event) {
      var id, values;
      event.append(this.form);
      this.reset();
      id = event.find('.ID').text();
      values = this.list.get('ID', id)[0].values();
      this.form.find('input[name=event_id]').val(id);
      this.form.find('input[name=venue]').val(values.venue);
      this.form.find('input[name=city]').val(values.city);
      this.form.find('input[name=tickets_url]').val(values.tickets_url);
      this.form.find('input[name=tickets_button]').val(values.tickets_button);
      this.tickets_status.value(values.tickets_status);
      this.datetime.value(values.event_date - this.editor.dateoffset(), values.enddate - this.editor.dateoffset());
      return event.addClass('edit');
    };

    wpt_events.prototype["delete"] = function(event) {
      var confirm_message, id, title, values;
      id = event.find('.ID').text();
      values = this.list.get('ID', id)[0].values();
      title = jQuery(values.datetime_html).find('.wp_theatre_event_date').text();
      title += ' ';
      title += jQuery(values.datetime_html).find('.wp_theatre_event_time').text();
      confirm_message = wpt_editor_ajax.confirm_message_event.replace(/%s/g, title);
      if (confirm(confirm_message)) {
        return this.list.remove('ID', id);
      }
    };

    wpt_events.prototype.reset = function() {
      this.events.find('.edit').removeClass('edit');

      /*
      			Set form inputs to defaults.
       */
      this.datetime.reset();
      this.form.find('input[name=venue]').removeAttr('value');
      this.form.find('input[name=city]').removeAttr('value');
      this.form.find('input[name=tickets_url]').removeAttr('value');
      this.form.find('input[name=tickets_button]').removeAttr('value');
      return this.activate();
    };

    wpt_events.prototype.close = function() {
      var enddate, event_date, id, item, values, _ref;
      _ref = this.datetime.value(), event_date = _ref[0], enddate = _ref[1];
      values = {
        event_date: event_date + this.editor.dateoffset(),
        enddate: enddate + this.editor.dateoffset(),
        venue: this.form.find('input[name=venue]').val(),
        city: this.form.find('input[name=city]').val(),
        tickets_url: this.form.find('input[name=tickets_url]').val(),
        tickets_button: this.form.find('input[name=tickets_button]').val(),
        tickets_status: this.tickets_status.value(),
        edit_link: '<a href="#">Edit</a>',
        delete_link: '<a href="#">Delete</a>'
      };
      values[wpt_editor_ajax.order_key] = values.event_date;
      id = this.form.find('input[name=event_id]').val();
      if ((id != null) && id !== '') {
        item = this.list.get('ID', id)[0];
        item.values(values);
      } else {
        this.list.add(values);
      }
      this.list.sort(wpt_editor_ajax.order_key);
      return this.reset();
    };

    return wpt_events;

  })();

  WPT_Editor_Date = (function() {
    function WPT_Editor_Date(datetime) {
      var date;
      this.datetime = datetime;
      if (this.datetime == null) {
        date = new Date();
        this.datetime = wpt_editor_ajax.default_date - wpt_editor_ajax.gmt_offset * 60 * 60 - date.getTimezoneOffset() * 60 * -1;
      }
    }

    WPT_Editor_Date.prototype.object = function() {
      return new Date(this.datetime * 1000);
    };

    WPT_Editor_Date.prototype.date = function() {
      return jQuery.datepicker.formatDate(this.date_format(), this.object());
    };

    WPT_Editor_Date.prototype.time = function() {
      var hours, minutes;
      hours = this.object().getHours();
      if (hours < 10) {
        hours = '0' + hours;
      }
      minutes = this.object().getMinutes();
      if (minutes < 10) {
        minutes = '0' + minutes;
      }
      return hours + ':' + minutes;
    };

    WPT_Editor_Date.prototype.date_format = function() {
      var format, javascript, php, translate;
      format = wpt_editor_ajax.date_format;
      translate = {
        'd': 'dd',
        'D': 'D',
        'j': 'd',
        'l': 'DD',
        'N': '',
        'S': '',
        'w': '',
        'z': 'o',
        'W': '',
        'F': 'MM',
        'm': 'mm',
        'M': 'M',
        'n': 'm',
        't': '',
        'L': '',
        'o': '',
        'Y': 'yy',
        'y': 'y'
      };
      for (php in translate) {
        javascript = translate[php];
        format = format.replace(php, javascript);
      }
      return format;
    };

    WPT_Editor_Date.prototype["import"] = function(formatted_date, formatted_time) {
      var hours, minutes, _ref;
      this.datetime = Math.floor((jQuery.datepicker.formatDate('@', formatted_date.datepicker('getDate'))) / 1000);
      _ref = formatted_time.val().split(':'), hours = _ref[0], minutes = _ref[1];
      if ((jQuery.isNumeric(hours)) && (jQuery.isNumeric(minutes))) {
        this.datetime += hours * 60 * 60 + minutes * 60;
      }
      return this;
    };

    return WPT_Editor_Date;

  })();

  WPT_Editor_Datetime_Control = (function() {
    function WPT_Editor_Datetime_Control(form) {
      var date;
      this.form = form;
      date = new WPT_Editor_Date();
      this.event_date_date = this.form.find('input[name=event_date_date]');
      this.event_date_time = this.form.find('input[name=event_date_time]');
      this.enddate_date = this.form.find('input[name=enddate_date]');
      this.enddate_time = this.form.find('input[name=enddate_time]');
      this.event_date_date.datepicker('destroy');
      this.event_date_date.datepicker({
        dateFormat: date.date_format(),
        defaultDate: date.object(),
        onSelect: (function(_this) {
          return function(DateText, inst) {
            var enddate;
            enddate = new WPT_Editor_Date();
            enddate["import"](_this.event_date_date, _this.event_date_time).datetime += wpt_editor_ajax.default_duration * 1;
            _this.enddate_date.val(enddate.date());
            _this.enddate_time.val(enddate.time());
            _this.sanitize();
            return _this.enddate_date.datepicker('option', 'minDate', enddate.object());
          };
        })(this)
      });
      this.enddate_date.datepicker('destroy');
      this.enddate_date.datepicker({
        dateFormat: date.date_format(),
        defaultDate: date.object(),
        minDate: this.event_date_date.datepicker('getDate'),
        onSelect: (function(_this) {
          return function(DateText, inst) {
            return _this.sanitize();
          };
        })(this)
      });
      this.event_date_time.change((function(_this) {
        return function() {
          return _this.sanitize();
        };
      })(this));
      this.enddate_time.change((function(_this) {
        return function() {
          return _this.sanitize();
        };
      })(this));
    }

    WPT_Editor_Datetime_Control.prototype.sanitize = function() {
      var enddate, event_date;
      event_date = new WPT_Editor_Date();
      enddate = new WPT_Editor_Date();

      /*
      		Time input value must be like 00:00.
       */
      this.event_date_time.val(event_date["import"](this.event_date_date, this.event_date_time).time());
      this.enddate_time.val(enddate["import"](this.enddate_date, this.enddate_time).time());

      /*
      		Enddate must be later than event_date.
       */
      if (enddate.datetime < event_date.datetime) {
        enddate.datetime = event_date.datetime + wpt_editor_ajax.default_duration * 1;
        this.enddate_date.val(enddate.date());
        return this.enddate_time.val(enddate.time());
      }
    };

    WPT_Editor_Datetime_Control.prototype.value = function(event_date, enddate) {
      if (event_date != null) {
        event_date = new WPT_Editor_Date(event_date);
        this.event_date_date.val(event_date.date());
        this.event_date_time.val(event_date.time());
        this.event_date_date.datepicker('setDate', event_date.object());
      } else {
        event_date = new WPT_Editor_Date();
      }
      if (enddate != null) {
        enddate = new WPT_Editor_Date(enddate);
        this.enddate_date.val(enddate.date());
        this.enddate_time.val(enddate.time());
        this.enddate_date.datepicker('setDate', enddate.object());
      } else {
        enddate = new WPT_Editor_Date();
      }
      return [event_date["import"](this.event_date_date, this.event_date_time).datetime, enddate["import"](this.enddate_date, this.enddate_time).datetime];
    };

    WPT_Editor_Datetime_Control.prototype.reset = function() {
      var event_date;
      event_date = new WPT_Editor_Date();
      return this.value(event_date.datetime, event_date.datetime + wpt_editor_ajax.default_duration * 1);
    };

    return WPT_Editor_Datetime_Control;

  })();

  WPT_Editor_Status_Control = (function() {
    function WPT_Editor_Status_Control(form) {
      this.form = form;
      this.control = this.form.find('.tickets_status_control');
      this.select = this.control.find('select[name=tickets_status]');
      this.other = this.control.find('input[name=tickets_status_other]');
      this.select.change((function(_this) {
        return function() {
          return _this.sanitize();
        };
      })(this));
    }

    WPT_Editor_Status_Control.prototype.sanitize = function() {
      if (this.select.val() === wpt_editor_ajax.tickets_status_other) {
        return this.other.show().focus();
      } else {
        return this.other.hide();
      }
    };

    WPT_Editor_Status_Control.prototype.value = function(tickets_status) {
      var option;
      if ((tickets_status != null) && (tickets_status !== '')) {
        option = this.select.find('option[value=' + tickets_status + ']');
        if (option.length) {
          this.select.val(tickets_status);
          this.other.removeAttr('value');
        } else {
          this.select.val(wpt_editor_ajax.tickets_status_other);
          this.other.val(tickets_status);
        }
      }
      this.sanitize();
      if (this.select.val() === wpt_editor_ajax.tickets_status_other) {
        return this.other.val();
      } else {
        return this.select.val();
      }
    };

    return WPT_Editor_Status_Control;

  })();

  WPT_Editor_Thumbnail_Control = (function() {
    function WPT_Editor_Thumbnail_Control(form) {
      this.form = form;
      this.control = this.form.find('.thumbnail_control');
      this.input = this.control.find('input[name=thumbnail]');
      this.img = this.control.find('img');
      this.control.click((function(_this) {
        return function() {
          if (!_this.control.hasClass('selected')) {
            return _this.edit();
          }
        };
      })(this));
      this.actions = this.control.find('.actions');
      this.actions.find('.edit_link').click((function(_this) {
        return function() {
          _this.edit();
          return false;
        };
      })(this));
      this.actions.find('.remove_link').click((function(_this) {
        return function() {
          _this.reset();
          return false;
        };
      })(this));
    }

    WPT_Editor_Thumbnail_Control.prototype.edit = function() {
      wp.media.editor.send.attachment = (function(_this) {
        return function(props, attachment) {
          _this.input.val(attachment.id);
          _this.img.attr('src', attachment.sizes.thumbnail.url);
          return _this.control.addClass('selected');
        };
      })(this);
      return wp.media.editor.open(this);
    };

    WPT_Editor_Thumbnail_Control.prototype.reset = function() {
      this.input.removeAttr('value');
      this.img.removeAttr('src');
      return this.control.removeClass('selected');
    };

    WPT_Editor_Thumbnail_Control.prototype.value = function() {
      return this.input.val();
    };

    return WPT_Editor_Thumbnail_Control;

  })();

  jQuery(function() {
    var editor;
    if ((editor = jQuery('#wpt_editor')) && editor.length) {
      return new wpt_editor(editor);
    }
  });


  /*
  --------------------------------------------
       Begin admin.coffee
  --------------------------------------------
   */

  wpt_admin_ticketspage = (function() {
    function wpt_admin_ticketspage() {
      this.ticketspage = jQuery('select#iframepage').parents('tr');
      this.integrationstypes = jQuery("input[name='wpt_tickets[integrationtype]']");
      if (this.ticketspage.length > 0 && this.integrationstypes.length > 0) {
        this.update();
        this.integrationstypes.click((function(_this) {
          return function() {
            return _this.update();
          };
        })(this));
      }
    }

    wpt_admin_ticketspage.prototype.update = function() {
      var integrationtype;
      integrationtype = jQuery("input[name='wpt_tickets[integrationtype]']:checked").val();
      if (integrationtype === 'iframe') {
        return this.ticketspage.show(1000);
      } else {
        return this.ticketspage.hide(500);
      }
    };

    return wpt_admin_ticketspage;

  })();

  jQuery(function() {
    wpt_admin_ticketspage = new wpt_admin_ticketspage;

    /*
    	Enable datepicker in event admin form.
     */
    jQuery('.wp_theatre_datepicker').datetimepicker({
      dateFormat: 'yy-mm-dd',
      timeFormat: 'HH:mm:ss'
    });

    /*
    	Update all connected events when bulk updating productions.
    	See: http://codex.wordpress.org/Plugin_API/Action_Reference/bulk_edit_custom_box
     */
    return jQuery('#bulk_edit').live('click', function() {
      var bulk_row, post_ids, post_status;
      bulk_row = jQuery('#bulk-edit');
      post_ids = new Array();
      bulk_row.find('#bulk-titles').children().each(function() {
        return post_ids.push(jQuery(this).attr('id').replace(/^(ttle)/i, ''));
      });
      post_status = bulk_row.find('select[name="_status"]').val();
      return jQuery.ajax({
        url: ajaxurl,
        type: 'POST',
        async: false,
        cache: false,
        data: {
          action: 'save_bulk_edit_wp_theatre_prod',
          post_ids: post_ids,
          post_status: post_status
        }
      });
    });
  });

}).call(this);
